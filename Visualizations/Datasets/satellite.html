<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Space Missions Satellite Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      background: linear-gradient(to bottom, #0a0a23, #1a2a6c);
      color: white;
      font-family: 'Orbitron', sans-serif;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      position: relative;
    }
    #chart-container {
      position: relative;
      margin-top: 20px;
    }
    svg {
      background: transparent;
    }
    #tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.9);
      color: #e0e0e0;
      padding: 10px;
      border-radius: 5px;
      pointer-events: none;
      display: none;
      font-size: 12px;
      border: 1px solid #4a90e2;
      box-shadow: 0 0 15px rgba(74, 144, 226, 0.5);
      z-index: 100;
    }
    .star {
      position: fixed;
      background: white;
      border-radius: 50%;
      opacity: 0.6;
      animation: twinkle 3s infinite alternate;
      z-index: 0;
    }
    @keyframes twinkle {
      0% { opacity: 0.6; }
      50% { opacity: 0.2; }
      100% { opacity: 0.7; }
    }
    .bubble {
      opacity: 0;
      transition: opacity 1s ease, filter 0.3s ease;
    }
    .bubble.visible {
      opacity: 0.9;
    }
    .bubble:hover {
      opacity: 1;
      filter: drop-shadow(0 0 18px #a0c4ff);
    }
    .bubble.glow {
      filter: drop-shadow(0 0 8px #a0c4ff) brightness(1.3);
    }
    #filter-container {
      margin: 20px 0;
      display: flex;
      gap: 20px;
      align-items: center;
      z-index: 1;
    }
    select {
      padding: 8px 12px;
      font-family: 'Orbitron', sans-serif;
      background: rgba(26, 42, 108, 0.7);
      color: white;
      border: 1px solid #4a90e2;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0 0 8px rgba(74, 144, 226, 0.3);
      transition: all 0.3s ease;
    }
    select:hover {
      box-shadow: 0 0 12px rgba(74, 144, 226, 0.6);
    }
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      color: white;
      z-index: 100;
      text-shadow: 0 0 10px #4a90e2;
    }
    .rect-outline {
      fill: none;
      stroke: #a0c4ff;
      stroke-width: 3;
      opacity: 0.9;
      filter: drop-shadow(0 0 12px #a0c4ff);
    }
    .solar-panel {
      fill: rgba(160, 196, 255, 0.1);
      stroke: #a0c4ff;
      stroke-width: 2;
      opacity: 0.8;
      filter: drop-shadow(0 0 8px #a0c4ff);
    }
    .grid-line {
      stroke: #a0c4ff;
      stroke-width: 1;
      stroke-opacity: 0.7;
    }
    .antenna {
      fill: none;
      stroke: #a0c4ff;
      stroke-width: 2;
      opacity: 0.9;
      filter: drop-shadow(0 0 10px #a0c4ff);
    }
    .antenna-dish {
      fill: rgba(160, 196, 255, 0.05);
      stroke: #a0c4ff;
      stroke-width: 2;
      opacity: 0.9;
    }
    .antenna-connection {
      stroke: #a0c4ff;
      stroke-width: 1.5;
      opacity: 0.8;
    }
    .year-label {
      font-size: 12px;
      fill: rgba(255, 255, 255, 0.7);
    }
    .connection-line {
      stroke: #a0c4ff;
      stroke-width: 1;
      stroke-opacity: 0.4;
      stroke-dasharray: 3,3;
      filter: drop-shadow(0 0 5px #a0c4ff);
      pointer-events: none;
      animation: line-flow 2s infinite linear;
    }
    @keyframes line-flow {
      0% { stroke-dashoffset: 0; }
      100% { stroke-dashoffset: -12; }
    }
    .thruster {
      fill: rgba(255, 100, 50, 0.3);
      stroke: #ff6432;
      stroke-width: 1;
      filter: drop-shadow(0 0 8px #ff6432);
    }
    .thruster-glow {
      fill: rgba(255, 100, 50, 0.05);
      animation: thruster-pulse 2s infinite alternate;
    }
    @keyframes thruster-pulse {
      0% { fill: rgba(255, 100, 50, 0.05); }
      100% { fill: rgba(255, 100, 50, 0.2); }
    }
    .orbit-line {
      fill: none;
      stroke: rgba(160, 196, 255, 0.15);
      stroke-width: 1;
      stroke-dasharray: 5,5;
    }
    .title {
      font-size: 24px;
      margin-top: 20px;
      text-shadow: 0 0 10px #4a90e2;
      z-index: 1;
    }
    .legend {
      display: flex;
      gap: 20px;
      margin-top: 10px;
      font-size: 12px;
      z-index: 1;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <div id="loading">Loading space missions data...</div>
  
  <h1 class="title">Space Missions Timeline (1960-2023)</h1>
  
  <div class="legend">
    <div class="legend-item">
      <div class="legend-color" style="background: #e0e0ff;"></div>
      <span>High Success Rate</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #ff8080;"></div>
      <span>Low Success Rate</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: transparent; border: 1px solid #a0c4ff;"></div>
      <span>Bubble Size = Mission Count</span>
    </div>
  </div>
  
  <div id="filter-container">
    <label for="company-filter">Filter by Company: </label>
    <select id="company-filter">
      <option value="all">All Companies</option>
    </select>
  </div>
  <div id="chart-container"></div>
  <div id="tooltip"></div>

  <script>
    for (let i = 0; i < 300; i++) {
      const star = document.createElement('div');
      star.className = 'star';
      
      const size = Math.random() * 3;
      star.style.width = star.style.height = `${size}px`;
      
      star.style.left = `${Math.random() * 100}%`;
      star.style.top = `${Math.random() * 100}%`;
      
      star.style.animationDelay = `${Math.random() * 5}s`;
      
      const hue = 200 + Math.random() * 40;
      const saturation = 50 + Math.random() * 50;
      const lightness = 80 + Math.random() * 20;
      star.style.background = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
      
      document.body.appendChild(star);
    }
    const width = 1600;
    const height = 1200;
    const margin = { top: 200, right: 100, bottom: 100, left: 100 };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;

    const svg = d3.select('#chart-container')
      .append('svg')
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', `0 0 ${width} ${height}`)
      .attr('preserveAspectRatio', 'xMidYMid meet');
    const orbits = svg.append('g')
      .attr('class', 'orbits');
    
    for (let i = 1; i <= 3; i++) {
      const orbitRadius = 800 + i * 200;
      orbits.append('ellipse')
        .attr('class', 'orbit-line')
        .attr('cx', width / 2)
        .attr('cy', height / 2)
        .attr('rx', orbitRadius)
        .attr('ry', orbitRadius / 2)
        .style('transform', 'rotate(-10deg)');
    }

    const chartGroup = svg.append('g')
      .attr('transform', `translate(${margin.left + chartWidth / 2},${margin.top + chartHeight / 2}) rotate(45) translate(${-chartWidth / 2},${-chartHeight / 2})`);

    const tooltip = d3.select('#tooltip');
    const loadingDiv = document.getElementById('loading');
    const centerX = chartWidth / 2;
    const rectWidth = 600;
    const rectHeight = 600;
    const rectPath = `
      M${centerX - rectWidth / 2},0
      L${centerX + rectWidth / 2},0
      L${centerX + rectWidth / 2},${rectHeight}
      L${centerX - rectWidth / 2},${rectHeight}
      Z
    `;
    chartGroup.append('path')
      .attr('class', 'rect-outline')
      .attr('d', rectPath);
    const innerPanelSize = 40;
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        if (i === 1 && j === 1) continue;
        
        chartGroup.append('rect')
          .attr('x', centerX - rectWidth / 3 + i * rectWidth / 3 - innerPanelSize/2)
          .attr('y', rectHeight / 3 + j * rectHeight / 3 - innerPanelSize/2)
          .attr('width', innerPanelSize)
          .attr('height', innerPanelSize)
          .attr('fill', 'none')
          .attr('stroke', '#a0c4ff')
          .attr('stroke-width', 1)
          .attr('opacity', 0.5);
      }
    }
    const panelWidth = 180;
    const panelHeight = 450;
    const panelOffset = 15;
    const gridRows = 5;
    const gridCols = 3;
    const antennaRadius = 80;
    const antennaStemHeight = 100;
    const leftPanelPath = `
      M${centerX - rectWidth / 2 - panelWidth - panelOffset},${(rectHeight - panelHeight) / 2}
      L${centerX - rectWidth / 2 - panelOffset},${(rectHeight - panelHeight) / 2}
      L${centerX - rectWidth / 2 - panelOffset},${(rectHeight - panelHeight) / 2 + panelHeight}
      L${centerX - rectWidth / 2 - panelWidth - panelOffset},${(rectHeight - panelHeight) / 2 + panelHeight}
      Z
    `;
    chartGroup.append('path')
      .attr('class', 'solar-panel')
      .attr('d', leftPanelPath);
    const rightPanelPath = `
      M${centerX + rectWidth / 2 + panelOffset},${(rectHeight - panelHeight) / 2}
      L${centerX + rectWidth / 2 + panelWidth + panelOffset},${(rectHeight - panelHeight) / 2}
      L${centerX + rectWidth / 2 + panelWidth + panelOffset},${(rectHeight - panelHeight) / 2 + panelHeight}
      L${centerX + rectWidth / 2 + panelOffset},${(rectHeight - panelHeight) / 2 + panelHeight}
      Z
    `;
    chartGroup.append('path')
      .attr('class', 'solar-panel')
      .attr('d', rightPanelPath);
    const leftPanelX = centerX - rectWidth / 2 - panelWidth - panelOffset;
    const leftPanelY = (rectHeight - panelHeight) / 2;
    for (let i = 1; i < gridRows; i++) {
      const y = leftPanelY + (panelHeight / gridRows) * i;
      chartGroup.append('line')
        .attr('class', 'grid-line')
        .attr('x1', leftPanelX)
        .attr('y1', y)
        .attr('x2', leftPanelX + panelWidth)
        .attr('y2', y);
    }
    for (let i = 1; i < gridCols; i++) {
      const x = leftPanelX + (panelWidth / gridCols) * i;
      chartGroup.append('line')
        .attr('class', 'grid-line')
        .attr('x1', x)
        .attr('y1', leftPanelY)
        .attr('x2', x)
        .attr('y2', leftPanelY + panelHeight);
    }
    const rightPanelX = centerX + rectWidth / 2 + panelOffset;
    const rightPanelY = (rectHeight - panelHeight) / 2;
    for (let i = 1; i < gridRows; i++) {
      const y = rightPanelY + (panelHeight / gridRows) * i;
      chartGroup.append('line')
        .attr('class', 'grid-line')
        .attr('x1', rightPanelX)
        .attr('y1', y)
        .attr('x2', rightPanelX + panelWidth)
        .attr('y2', y);
    }
    for (let i = 1; i < gridCols; i++) {
      const x = rightPanelX + (panelWidth / gridCols) * i;
      chartGroup.append('line')
        .attr('class', 'grid-line')
        .attr('x1', x)
        .attr('y1', rightPanelY)
        .attr('x2', x)
        .attr('y2', rightPanelY + panelHeight);
    }
    for (let i = 0; i < gridCols; i++) {
      for (let j = 0; j < gridRows; j++) {
        if (Math.random() > 0.7) {
          const cellX = leftPanelX + (panelWidth / gridCols) * i;
          const cellY = leftPanelY + (panelHeight / gridRows) * j;
          const cellWidth = panelWidth / gridCols;
          const cellHeight = panelHeight / gridRows;
          
          chartGroup.append('rect')
            .attr('x', cellX)
            .attr('y', cellY)
            .attr('width', cellWidth)
            .attr('height', cellHeight)
            .attr('fill', 'rgba(160, 196, 255, 0.2)')
            .attr('stroke', 'none');
        }
        
        if (Math.random() > 0.7) {
          const cellX = rightPanelX + (panelWidth / gridCols) * i;
          const cellY = rightPanelY + (panelHeight / gridRows) * j;
          const cellWidth = panelWidth / gridCols;
          const cellHeight = panelHeight / gridRows;
          
          chartGroup.append('rect')
            .attr('x', cellX)
            .attr('y', cellY)
            .attr('width', cellWidth)
            .attr('height', cellHeight)
            .attr('fill', 'rgba(160, 196, 255, 0.2)')
            .attr('stroke', 'none');
        }
      }
    }
    const antennaCenterX = centerX;
    const antennaCenterY = -antennaStemHeight;
    
    chartGroup.append('ellipse')
      .attr('class', 'antenna-dish')
      .attr('cx', antennaCenterX)
      .attr('cy', antennaCenterY)
      .attr('rx', antennaRadius)
      .attr('ry', antennaRadius * 0.4)
      .attr('transform', `rotate(-15, ${antennaCenterX}, ${antennaCenterY})`);
      
    chartGroup.append('ellipse')
      .attr('class', 'antenna-dish')
      .attr('cx', antennaCenterX)
      .attr('cy', antennaCenterY)
      .attr('rx', antennaRadius * 0.7)
      .attr('ry', antennaRadius * 0.3)
      .attr('transform', `rotate(-15, ${antennaCenterX}, ${antennaCenterY})`);
      
    chartGroup.append('circle')
      .attr('cx', antennaCenterX)
      .attr('cy', antennaCenterY)
      .attr('r', 5)
      .attr('fill', '#a0c4ff')
      .attr('filter', 'drop-shadow(0 0 8px #a0c4ff)');
      
    chartGroup.append('line')
      .attr('class', 'antenna')
      .attr('x1', antennaCenterX - antennaRadius * 0.9)
      .attr('y1', antennaCenterY)
      .attr('x2', antennaCenterX + antennaRadius * 0.9)
      .attr('y2', antennaCenterY)
      .attr('transform', `rotate(-15, ${antennaCenterX}, ${antennaCenterY})`);
      
    chartGroup.append('line')
      .attr('class', 'antenna')
      .attr('x1', antennaCenterX)
      .attr('y1', antennaCenterY - antennaRadius * 0.36)
      .attr('x2', antennaCenterX)
      .attr('y2', antennaCenterY + antennaRadius * 0.36)
      .attr('transform', `rotate(-15, ${antennaCenterX}, ${antennaCenterY})`);

    const stemPath = `
      M${antennaCenterX},0
      L${antennaCenterX},${-antennaStemHeight/3}
      L${antennaCenterX - 15},${-antennaStemHeight/3 - 15}
      L${antennaCenterX},${-antennaStemHeight/3 - 30}
      L${antennaCenterX},${antennaCenterY}
    `;
    
    chartGroup.append('path')
      .attr('class', 'antenna')
      .attr('d', stemPath)
      .attr('fill', 'none');
      
    chartGroup.append('line')
      .attr('class', 'antenna-connection')
      .attr('x1', antennaCenterX)
      .attr('y1', -antennaStemHeight/3 - 15)
      .attr('x2', antennaCenterX + 15)
      .attr('y2', -antennaStemHeight/3 - 15);
      
    chartGroup.append('line')
      .attr('class', 'antenna-connection')
      .attr('x1', antennaCenterX)
      .attr('y1', -10)
      .attr('x2', antennaCenterX - 20)
      .attr('y2', -30);
      
    chartGroup.append('line')
      .attr('class', 'antenna-connection')
      .attr('x1', antennaCenterX)
      .attr('y1', -10)
      .attr('x2', antennaCenterX + 20)
      .attr('y2', -30);
    const thrusterSize = 15;
    const thrusterPositions = [
      { x: centerX - rectWidth / 2, y: rectHeight + thrusterSize },
      { x: centerX + rectWidth / 2, y: rectHeight + thrusterSize },
      { x: centerX - rectWidth / 2, y: -thrusterSize },
      { x: centerX + rectWidth / 2, y: -thrusterSize }
    ];
    
    thrusterPositions.forEach((pos, i) => {
      chartGroup.append('circle')
        .attr('class', 'thruster')
        .attr('cx', pos.x)
        .attr('cy', pos.y)
        .attr('r', thrusterSize);
        
      chartGroup.append('circle')
        .attr('class', 'thruster-glow')
        .attr('cx', pos.x)
        .attr('cy', pos.y)
        .attr('r', thrusterSize * 2)
        .style('animation-delay', `${i * 0.5}s`);
        
      const connectX = pos.x + (pos.x < centerX ? thrusterSize : -thrusterSize);
      chartGroup.append('line')
        .attr('class', 'thruster')
        .attr('x1', pos.x)
        .attr('y1', pos.y)
        .attr('x2', connectX)
        .attr('y2', pos.y);
    });
    function isInsideRect(x, y) {
      const rectLeft = centerX - rectWidth / 2;
      const rectRight = centerX + rectWidth / 2;
      const rectTop = 0;
      const rectBottom = rectHeight;
      return x >= rectLeft && x <= rectRight && y >= rectTop && y <= rectBottom;
    }
    function loadDataOrCreateMock() {
      return fetch('Datasets/Space_Corrected.csv')
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          return response.text();
        })
        .then(csvData => {
          return new Promise((resolve) => {
            Papa.parse(csvData, {
              header: true,
              skipEmptyLines: true,
              complete: (results) => {
                resolve(processData(results.data));
              },
              error: (err) => {
                console.error('Error parsing CSV:', err);
                resolve(createMockData());
              }
            });
          });
        })
        .catch(error => {
          console.warn('Failed to load CSV, using mock data instead:', error.message);
          return createMockData();
        });
    }

    function processData(rawData) {
      return rawData
        .filter(d => {
          const hasRequiredFields = d.Datum && d['Company Name'] && d['Status Mission'];
          if (!hasRequiredFields) {
            console.warn('Skipping row due to missing required fields:', d);
          }
          return hasRequiredFields;
        })
        .map(d => {
          let year;
          try {
            const dateParts = d.Datum.split(' ');
            if (dateParts.length >= 4) {
              year = parseInt(dateParts[3].replace(',', ''));
            } else if (d.Datum.includes('-')) {
              year = parseInt(d.Datum.split('-')[0]);
            } else {
              const dateObj = new Date(d.Datum);
              year = dateObj.getFullYear();
            }

            if (isNaN(year)) {
              throw new Error(`Invalid year parsed from ${d.Datum}`);
            }
          } catch (e) {
            console.warn('Failed to parse date for row:', d.Datum, e.message);
            return null;
          }

          return {
            year: year,
            company: d['Company Name'],
            status: d['Status Mission'],
            detail: d.Detail || 'No details available',
          };
        })
        .filter(d => d !== null);
    }

    function createMockData() {
      const companies = ['SpaceX', 'NASA', 'Roscosmos', 'Blue Origin', 'Virgin Galactic', 
                        'ESA', 'ISRO', 'JAXA', 'Boeing', 'Lockheed Martin', 'Arianespace',
                        'ULA', 'Rocket Lab', 'CNSA', 'Northrop Grumman'];
      const missions = ['Falcon Heavy', 'Crew Dragon', 'Apollo', 'Shuttle', 'Mercury', 
                       'Gemini', 'Soyuz', 'Progress', 'Vostok', 'Galileo', 'Mars Rover',
                       'New Horizons', 'Starlink', 'Orion', 'Juno', 'Webb Telescope',
                       'Cassini', 'Voyager', 'Pioneer', 'Curiosity', 'Opportunity'];
      const statuses = ['Success', 'Failure', 'Partial Failure', 'Success', 'Success'];
      
      const mockData = [];
      const startYear = 1960;
      const endYear = 2023;
      
      for (let i = 0; i < 800; i++) {
        const year = Math.floor(Math.random() * (endYear - startYear + 1)) + startYear;
        const company = companies[Math.floor(Math.random() * companies.length)];
        const mission = missions[Math.floor(Math.random() * missions.length)];
        const status = statuses[Math.floor(Math.random() * statuses.length)];
        
        mockData.push({
          year: year,
          company: company,
          status: status,
          detail: `${mission} mission to ${Math.random() > 0.5 ? 'orbit' : 'deep space'}`
        });
      }
      
      return mockData;
    }
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }
    loadDataOrCreateMock().then(allData => {
      if (allData.length === 0) {
        console.error('No valid data after filtering');
        loadingDiv.textContent = 'Error: No valid data found after parsing.';
        return;
      }
      const companies = [...new Set(allData.map(d => d.company))].sort();
      const companyFilter = d3.select('#company-filter');
      companyFilter.selectAll('option.company-option')
        .data(companies)
        .enter()
        .append('option')
        .attr('class', 'company-option')
        .attr('value', d => d)
        .text(d => d);
      function updateChart(selectedCompany) {
        const filteredData = selectedCompany === 'all'
          ? allData
          : allData.filter(d => d.company === selectedCompany);

        const aggregatedData = d3.group(filteredData, d => d.year, d => d.company);
        let chartData = [];
        let idCounter = 0;
        
        for (const [year, companies] of aggregatedData) {
          for (const [company, missions] of companies) {
            const successCount = missions.filter(m => m.status === 'Success').length;
            const total = missions.length;
            chartData.push({
              id: idCounter++,
              year: +year,
              company,
              successCount,
              total,
              successRate: successCount / total,
              missions,
              size: Math.max(8, Math.sqrt(total) * 3 * (0.7 + Math.random() * 0.6)),
              isClone: false
            });
          }
        }
        if (chartData.length < 250 && selectedCompany === 'all') {
          const extraData = [];
          chartData.forEach(d => {
            if (Math.random() > 0.65) {
              const clone = {...d};
              clone.id = idCounter++;
              clone.size = Math.max(6, d.size * (0.4 + Math.random() * 0.5));
              clone.isClone = true;
              extraData.push(clone);
            }
          });
          chartData = chartData.concat(extraData);
        }
        const colorScale = d3.scaleLinear()
          .domain([0, 0.25, 0.65, 1])
          .range(['#ff4040', '#ff8080', '#a0c4ff', '#e0e0ff'])
          .interpolate(d3.interpolateHsl);
        chartGroup.selectAll('.bubble').remove();
        chartGroup.selectAll('.connection-line').remove();
        chartGroup.selectAll('.year-line').remove();
        chartGroup.selectAll('.year-label').remove();
        const rectLeft = centerX - rectWidth / 2;
        const rectRight = centerX + rectWidth / 2;
        const rectTop = 0;
        const rectBottom = rectHeight;
        chartData.forEach(d => {
          const yearRange = 2023 - 1960;
          const normalizedYear = (d.year - 1960) / yearRange;
          d.x = rectLeft + Math.random() * rectWidth;
          d.y = rectBottom - normalizedYear * rectHeight * 0.95 - Math.random() * rectHeight * 0.05;
          d.x = Math.max(rectLeft + d.size, Math.min(rectRight - d.size, d.x));
          d.y = Math.max(rectTop + d.size, Math.min(rectBottom - d.size, d.y));
        });
        const simulation = d3.forceSimulation(chartData)
          .force('collide', d3.forceCollide(d => d.size + 4).iterations(6))
          .force('center', d3.forceCenter(centerX, rectTop + rectHeight / 2).strength(0.015))
          .force('y', d3.forceY(d => {
            const yearRange = 2023 - 1960;
            const normalizedYear = (d.year - 1960) / yearRange;
            return rectBottom - normalizedYear * rectHeight;
          }).strength(0.12))
          .force('boundary', () => {
            chartData.forEach(d => {
              if (d.x - d.size < rectLeft) d.x = rectLeft + d.size;
              if (d.x + d.size > rectRight) d.x = rectRight - d.size;
              if (d.y - d.size < rectTop) d.y = rectTop + d.size;
              if (d.y + d.size > rectBottom) d.y = rectBottom - d.size;
            });
          })
          .alphaDecay(0.008)
          .velocityDecay(0.35);
        const bubbles = chartGroup.selectAll('.bubble')
          .data(chartData)
          .enter()
          .append('circle')
          .attr('class', 'bubble')
          .attr('r', d => d.size)
          .attr('fill', d => {
            const baseColor = d3.color(colorScale(d.successRate));
            baseColor.r = Math.max(0, Math.min(255, baseColor.r + Math.random() * 15 - 7.5));
            baseColor.g = Math.max(0, Math.min(255, baseColor.g + Math.random() * 15 - 7.5));
            baseColor.b = Math.max(0, Math.min(255, baseColor.b + Math.random() * 15 - 7.5));
            return baseColor;
          })
          .attr('stroke', '#ffffff')
          .attr('stroke-width', 0.3)
          .attr('fill-opacity', 0.85 + Math.random() * 0.15);
        const handleMouseOver = debounce((event, d) => {
          d.fx = d.x;
          d.fy = d.y;
          chartGroup.selectAll('.connection-line').remove();
          tooltip
            .html(`
              <strong>${d.company}</strong> (${d.year})<br>
              Total Missions: ${d.total}<br>
              Success Rate: ${(d.successRate * 100).toFixed(1)}%<br>
              Sample Mission: ${d.missions[0].detail}
            `);
          const offsetX = 15;
          const offsetY = 15;
          let tooltipX = event.clientX + offsetX;
          let tooltipY = event.clientY + offsetY;
          const tooltipRect = tooltip.node().getBoundingClientRect();
          const tooltipWidth = tooltipRect.width;
          const tooltipHeight = tooltipRect.height;
          if (tooltipX + tooltipWidth > window.innerWidth - 10) {
            tooltipX = event.clientX - tooltipWidth - offsetX;
          }
          if (tooltipY + tooltipHeight > window.innerHeight - 10) {
            tooltipY = event.clientY - tooltipHeight - offsetY;
          }
          tooltipX = Math.max(10, Math.min(tooltipX, window.innerWidth - tooltipWidth - 10));
          tooltipY = Math.max(10, Math.min(tooltipY, window.innerHeight - tooltipHeight - 10));

          tooltip
            .style('display', 'block')
            .style('left', `${tooltipX}px`)
            .style('top', `${tooltipY}px`);
          const relatedBubbles = chartData.filter(b => 
            b.company === d.company && 
            b.id !== d.id && 
            !b.isClone
          );
          const connections = relatedBubbles.map(related => ({
            source: d,
            target: related
          }));

          chartGroup.selectAll('.connection-line')
            .data(connections)
            .enter()
            .append('line')
            .attr('class', 'connection-line')
            .attr('x1', conn => conn.source.x)
            .attr('y1', conn => conn.source.y)
            .attr('x2', conn => conn.target.x)
            .attr('y2', conn => conn.target.y);

          bubbles.classed('glow', b => b.company === d.company && b.id !== d.id && !b.isClone);
        }, 50);

        const handleMouseOut = debounce((event, d) => {
          d.fx = null;
          d.fy = null;

          tooltip.style('display', 'none');
          chartGroup.selectAll('.connection-line').remove();
          bubbles.classed('glow', false);
        }, 50);

        bubbles
          .on('mouseover', handleMouseOver)
          .on('mouseout', handleMouseOut);
        simulation
          .on('tick', () => {
            bubbles
              .attr('cx', d => d.x)
              .attr('cy', d => d.y);
          })
          .on('end', () => {
            bubbles.each(function(d) {
              if (d.x - d.size < rectLeft) d.x = rectLeft + d.size;
              if (d.x + d.size > rectRight) d.x = rectRight - d.size;
              if (d.y - d.size < rectTop) d.y = rectTop + d.size;
              if (d.y + d.size > rectBottom) d.y = rectBottom - d.size;
              
              d3.select(this)
                .attr('cx', d.x)
                .attr('cy', d.y);
            });
          });
        const years = [1990, 2000, 2010];
        years.forEach(year => {
          const yearPosition = rectBottom - ((year - 1960) / (2023 - 1960)) * rectHeight;
          
          chartGroup.append('line')
            .attr('class', 'year-line')
            .attr('x1', rectLeft - 60)
            .attr('y1', yearPosition)
            .attr('x2', rectRight + 60)
            .attr('y2', yearPosition)
            .attr('stroke', 'rgba(255,255,255,0.3)')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '3,3');
            
          chartGroup.append('text')
            .attr('class', 'year-label')
            .attr('x', rectLeft - 80)
            .attr('y', yearPosition + 5)
            .text(year);
        });
        setTimeout(() => {
          bubbles.classed('visible', true);
        }, 500);
      }
      updateChart('all');
      d3.select('#company-filter').on('change', function() {
        const selectedCompany = this.value;
        updateChart(selectedCompany);
      });

      loadingDiv.style.display = 'none';
    }).catch(error => {
      console.error('Failed to process data:', error);
      loadingDiv.textContent = 'Error: Could not load or process data.';
    });
  </script>
</body>
</html>