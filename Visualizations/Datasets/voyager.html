<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voyager 1 & 2 Trajectories (1977â€“2025)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chrono-node/1.3.11/chrono.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: radial-gradient(circle at center, #0a0a23 0%, #000000 70%);
      color: #e5e5e5;
      font-family: 'Roboto', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow: auto;
    }
    #visualization-container {
      width: 100%;
      max-width: 1200px;
      display: flex;
      position: relative;
    }
    #visualization {
      width: 100%;
      height: 800px;
      position: relative;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 1;
      margin-right: 15px;
      padding-top: 20px;
    }
    .starry-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }
    .star {
      fill: #ffffff;
      opacity: 0.7;
    }
    .orbit {
      fill-opacity: 0.1;
      stroke-opacity: 0.5;
    }
    .orbit-earth {
      fill: #99ccff;
      stroke: #99ccff;
    }
    .orbit-jupiter {
      fill: #ffcc99;
      stroke: #ffcc99;
    }
    .orbit-saturn {
      fill: #ffeb99;
      stroke: #ffeb99;
    }
    .orbit-uranus {
      fill: #99ccff;
      stroke: #99ccff;
    }
    .orbit-neptune {
      fill: #6699ff;
      stroke: #6699ff;
    }
    .earth {
      fill: #1e90ff;
    }
    .trajectory-v1 {
      fill: none;
      stroke: #f4a261;
      stroke-width: 1.5;
      stroke-dasharray: 3,3;
    }
    .trajectory-v2 {
      fill: none;
      stroke: #e76f51;
      stroke-width: 1.5;
      stroke-dasharray: 3,3;
    }
    .sun {
      fill: url(#sun-gradient);
    }
    .spacecraft-v1 {
      fill: url(#spacecraft-v1-gradient);
      cursor: pointer;
    }
    .spacecraft-v2 {
      fill: url(#spacecraft-v2-gradient);
      cursor: pointer;
    }
    .label {
      fill: #e5e5e5;
      font-size: 12px;
      text-anchor: middle;
      text-shadow: 0 0 3px #000;
    }
    .spacecraft-label {
      font-size: 14px;
      font-weight: bold;
    }
    .popup {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      pointer-events: none;
      display: none;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      z-index: 10;
    }
    .control-button {
      background: rgba(255, 255, 255, 0.1);
      color: #e5e5e5;
      border: 1px solid #e5e5e5;
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
      font-family: 'Roboto', Arial, sans-serif;
      font-size: 14px;
      transition: background 0.2s;
      width: 80px;
    }
    .control-button:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    .control-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .full-starry-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
      display: block;
    }
    #visualization svg {
      background: transparent;
    }
  </style>
</head>
<body>
  <canvas class="full-starry-background"></canvas>
  <div id="visualization-container">
    <div class="controls">
      <button id="play-pause" class="control-button">Pause</button>
      <button id="replay" class="control-button">Replay</button>
    </div>
    <div id="visualization">
      <div class="popup"></div>
    </div>
  </div>

  <script>
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }
    function updateStarryBackground() {
      const canvas = document.querySelector(".full-starry-background");
      if (!canvas) {
        console.warn("Starry background canvas not found");
        return;
      }
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        console.error("Failed to get canvas context");
        return;
      }
      const viewWidth = window.innerWidth;
      const viewHeight = window.innerHeight;
      canvas.width = viewWidth;
      canvas.height = viewHeight;
      const gradient = ctx.createRadialGradient(
        viewWidth / 2, viewHeight / 2, 0,
        viewWidth / 2, viewHeight / 2, viewWidth
      );
      gradient.addColorStop(0, "#0a0a23");
      gradient.addColorStop(1, "#000000");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, viewWidth, viewHeight);
      const starDensity = 0.0003; 
      const starCount = Math.floor(viewWidth * viewHeight * starDensity);
      for (let i = 0; i < starCount; i++) {
        const x = Math.random() * viewWidth;
        const y = Math.random() * viewHeight;
        const radius = Math.random() * 1.5 + 0.5;
        const opacity = Math.random() * 0.7 + 0.3;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.fill();
        if (Math.random() > 0.8) {
          const glow = ctx.createRadialGradient(x, y, 0, x, y, radius * 3);
          glow.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.7})`);
          glow.addColorStop(1, "rgba(255, 255, 255, 0)");
          
          ctx.beginPath();
          ctx.arc(x, y, radius * 3, 0, 2 * Math.PI);
          ctx.fillStyle = glow;
          ctx.fill();
        }
      }
      const coloredStarCount = Math.floor(starCount * 0.05);
      const starColors = ["#ff9999", "#99ccff", "#ffffaa", "#aaffaa"];
      
      for (let i = 0; i < coloredStarCount; i++) {
        const x = Math.random() * viewWidth;
        const y = Math.random() * viewHeight;
        const radius = Math.random() * 1.2 + 0.8;
        const opacity = Math.random() * 0.5 + 0.5;
        const color = starColors[Math.floor(Math.random() * starColors.length)];
        
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fillStyle = color.replace("rgb", "rgba").replace(")", `, ${opacity})`);
        ctx.fill();
      }
    }
    updateStarryBackground();
    const handleResize = debounce(() => {
      updateStarryBackground();
    }, 100);
    window.addEventListener("resize", handleResize);
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") {
        updateStarryBackground();
      }
    });
    Promise.all([
      fetch("Datasets/voyager1_ephemeris.csv").then(response => response.text()),
      fetch("Datasets/voyager2_ephemeris.csv").then(response => response.text())
    ]).then(([v1Csv, v2Csv]) => {
      Papa.parse(v1Csv, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        transformHeader: (header) => header.trim().replace(/^"|"$/g, ''),
        transform: (value, header) => value.trim().replace(/^"|"$/g, ''),
        complete: (v1Result) => {
          Papa.parse(v2Csv, {
            header: true,
            skipEmptyLines: true,
            dynamicTyping: false,
            transformHeader: (header) => header.trim().replace(/^"|"$/g, ''),
            transform: (value, header) => value.trim().replace(/^"|"$/g, ''),
            complete: (v2Result) => {
              const v1Data = processData(v1Result.data, "Voyager 1");
              const v2Data = processData(v2Result.data, "Voyager 2");
              drawVisualization([...v1Data, ...v2Data], v1Data, v2Data);
            }
          });
        }
      });
    }).catch(error => {
      console.error("Error loading CSV files:", error);
    });
    function processData(rawData, spacecraft) {
      return rawData
        .map((row) => {
          const date = chrono.parseDate(row["Date_UT"]);
          const year = date ? date.getFullYear() : null;
          const lon = parseFloat(row["Helio_Ecl_Lon"]);
          const lat = parseFloat(row["Helio_Ecl_Lat"]);
          const r = parseFloat(row["r"]);
          const skyMotion = parseFloat(row["Sky_motion"]);

          return {
            date: date,
            year: year,
            lon: !isNaN(lon) ? lon * (Math.PI / 180) : null,
            lat: !isNaN(lat) ? lat * (Math.PI / 180) : null,
            r: !isNaN(r) ? r : null,
            skyMotion: !isNaN(skyMotion) ? skyMotion : null,
            spacecraft: spacecraft,
          };
        })
        .filter(
          (row) =>
            row.date &&
            row.year &&
            row.lon !== null &&
            row.lat !== null &&
            row.r !== null &&
            row.skyMotion !== null
        )
        .sort((a, b) => a.date - b.date);
    }
    function drawVisualization(data, v1Data, v2Data) {
      const width = 1200;
      const height = 800;
      const maxR = d3.max(data, (d) => d.r);
      const rScale = d3.scaleLog()
        .domain([0.1, maxR])
        .range([5, 600])
        .clamp(true);
      data.forEach((d) => {
        const scaledR = rScale(d.r);
        d.x = scaledR * Math.cos(d.lon);
        d.y = scaledR * Math.sin(d.lon);
      });
      const earthR = rScale(1);
      v1Data[0].x = earthR;
      v1Data[0].y = 0;
      v2Data[0].x = earthR;
      v2Data[0].y = 0;
      const neptuneR = rScale(30.1);
      const initialViewBoxSize = neptuneR + 150;
      const svg = d3
        .select("#visualization")
        .append("svg")
        .attr("width", "100%")
        .attr("height", "100%")
        .attr("viewBox", `-${initialViewBoxSize} -${initialViewBoxSize} ${initialViewBoxSize * 2} ${initialViewBoxSize * 2}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .append("g");
      const planets = [
        { name: "Earth", r: 1, class: "orbit-earth", angle: 0 },
        { name: "Jupiter", r: 5.2, class: "orbit-jupiter", angle: 45 },
        { name: "Saturn", r: 9.5, class: "orbit-saturn", angle: 90 },
        { name: "Uranus", r: 19.2, class: "orbit-uranus", angle: 135 },
        { name: "Neptune", r: 30.1, class: "orbit-neptune", angle: 180 },
      ];
      const defs = svg.append("defs");
      const sunGradient = defs
        .append("radialGradient")
        .attr("id", "sun-gradient");
      sunGradient
        .append("stop")
        .attr("offset", "0%")
        .attr("stop-color", "#ffeb3b")
        .attr("stop-opacity", 1);
      sunGradient
        .append("stop")
        .attr("offset", "100%")
        .attr("stop-color", "#f57f17")
        .attr("stop-opacity", 0.5);
      const spacecraftV1Gradient = defs
        .append("radialGradient")
        .attr("id", "spacecraft-v1-gradient");
      spacecraftV1Gradient
        .append("stop")
        .attr("offset", "0%")
        .attr("stop-color", "#f4a261")
        .attr("stop-opacity", 1);
      spacecraftV1Gradient
        .append("stop")
        .attr("offset", "100%")
        .attr("stop-color", "#b5651d")
        .attr("stop-opacity", 0.8);

      const spacecraftV2Gradient = defs
        .append("radialGradient")
        .attr("id", "spacecraft-v2-gradient");
      spacecraftV2Gradient
        .append("stop")
        .attr("offset", "0%")
        .attr("stop-color", "#e76f51")
        .attr("stop-opacity", 1);
      spacecraftV2Gradient
        .append("stop")
        .attr("offset", "100%")
        .attr("stop-color", "#a33c2a")
        .attr("stop-opacity", 0.8);
      planets.forEach((planet) => {
        const orbitRadius = rScale(planet.r);
        svg
          .append("circle")
          .attr("class", `orbit ${planet.class}`)
          .attr("r", orbitRadius)
          .attr("cx", 0)
          .attr("cy", 0)
          .attr("stroke-width", 1.5);

        const angleRad = (planet.angle * Math.PI) / 180;
        const labelRadius = orbitRadius + 20;
        svg
          .append("text")
          .attr("class", "label")
          .attr("x", labelRadius * Math.cos(angleRad))
          .attr("y", labelRadius * Math.sin(angleRad))
          .text(planet.name);
      });
      svg
        .append("circle")
        .attr("class", "sun")
        .attr("r", 8)
        .attr("cx", 0)
        .attr("cy", 0);
      svg
        .append("circle")
        .attr("class", "earth")
        .attr("r", 4)
        .attr("cx", earthR)
        .attr("cy", 0);
      const line = d3
        .line()
        .x((d) => d.x)
        .y((d) => d.y)
        .curve(d3.curveCatmullRom);

      const v1Path = svg
        .append("path")
        .attr("class", "trajectory-v1")
        .datum([])
        .attr("d", line);

      const v2Path = svg
        .append("path")
        .attr("class", "trajectory-v2")
        .datum([])
        .attr("d", line);
      const v1Spacecraft = svg
        .append("circle")
        .attr("class", "spacecraft-v1")
        .attr("r", 5)
        .attr("cx", v1Data[0].x)
        .attr("cy", v1Data[0].y);

      const v2Spacecraft = svg
        .append("circle")
        .attr("class", "spacecraft-v2")
        .attr("r", 5)
        .attr("cx", v2Data[0].x)
        .attr("cy", v2Data[0].y);
      const v1Label = svg
        .append("text")
        .attr("class", "label spacecraft-label")
        .attr("x", v1Data[0].x + 30)
        .attr("y", v1Data[0].y)
        .text("Voyager 1")
        .attr("fill", "#f4a261");

      const v2Label = svg
        .append("text")
        .attr("class", "label spacecraft-label")
        .attr("x", v2Data[0].x + 30)
        .attr("y", v2Data[0].y)
        .text("Voyager 2")
        .attr("fill", "#e76f51");
      const popup = d3.select(".popup");
      let currentIndexV1 = 0;
      let currentIndexV2 = 0;
      let currentDate = new Date(1977, 7, 1);
      let isPlaying = true;
      let animationTimeout = null;

      function updatePositions(date) {
        currentDate = date;

        currentIndexV1 = v1Data.findIndex((d) => d.date >= currentDate);
        currentIndexV2 = v2Data.findIndex((d) => d.date >= currentDate);

        if (currentIndexV1 === -1 || currentIndexV1 >= v1Data.length) {
          currentIndexV1 = v1Data.length - 1;
        } else if (currentIndexV1 < 0) {
          currentIndexV1 = 0;
        }

        if (currentIndexV2 === -1 || currentIndexV2 >= v2Data.length) {
          currentIndexV2 = v2Data.length - 1;
        } else if (currentIndexV2 < 0) {
          currentIndexV2 = 0;
        }

        v1Spacecraft
          .attr("cx", v1Data[currentIndexV1].x)
          .attr("cy", v1Data[currentIndexV1].y);

        v2Spacecraft
          .attr("cx", v2Data[currentIndexV2].x)
          .attr("cy", v2Data[currentIndexV2].y);

        v1Path.datum(v1Data.slice(0, currentIndexV1 + 1)).attr("d", line);
        v2Path.datum(v2Data.slice(0, currentIndexV2 + 1)).attr("d", line);

        v1Label
          .attr("x", v1Data[currentIndexV1].x + 30)
          .attr("y", v1Data[currentIndexV1].y);

        v2Label
          .attr("x", v2Data[currentIndexV2].x + 30)
          .attr("y", v2Data[currentIndexV2].y);

        const minX = Math.min(v1Data[currentIndexV1].x, v2Data[currentIndexV2].x);
        const maxX = Math.max(v1Data[currentIndexV1].x, v2Data[currentIndexV2].x);
        const minY = Math.min(v1Data[currentIndexV1].y, v2Data[currentIndexV2].y);
        const maxY = Math.max(v1Data[currentIndexV1].y, v2Data[currentIndexV2].y);

        const sunX = 0;
        const sunY = 0;
        const adjustedMinX = Math.min(minX, sunX, -neptuneR) - 150;
        const adjustedMaxX = Math.max(maxX, sunX, neptuneR) + 150;
        const adjustedMinY = Math.min(minY, sunY, -neptuneR) - 150;
        const adjustedMaxY = Math.max(maxY, sunY, neptuneR) + 150;

        const newViewWidth = adjustedMaxX - adjustedMinX;
        const newViewHeight = adjustedMaxY - adjustedMinY;
        const viewSize = Math.max(newViewWidth, newViewHeight, neptuneR * 2 + 300);

        const newViewBox = [
          adjustedMinX - (viewSize - newViewWidth) / 2,
          adjustedMinY - (viewSize - newViewHeight) / 2,
          viewSize,
          viewSize
        ].join(" ");

        svg.node().parentNode.setAttribute("viewBox", newViewBox);
      }

      v1Spacecraft
        .on("mouseover", function (event) {
          const d = v1Data[currentIndexV1];
          popup
            .style("display", "block")
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 40) + "px")
            .html(`
              <strong>Voyager 1</strong><br>
              Date: ${d3.timeFormat("%d %b %Y")(d.date)}<br>
              Distance from Sun: ${d.r.toFixed(2)} AU<br>
              Sky Motion: ${d.skyMotion.toFixed(4)} arcsec/hr
            `);
        })
        .on("mouseout", function () {
          popup.style("display", "none");
        });

      v2Spacecraft
        .on("mouseover", function (event) {
          const d = v2Data[currentIndexV2];
          popup
            .style("display", "block")
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 40) + "px")
            .html(`
              <strong>Voyager 2</strong><br>
              Date: ${d3.timeFormat("%d %b %Y")(d.date)}<br>
              Distance from Sun: ${d.r.toFixed(2)} AU<br>
              Sky Motion: ${d.skyMotion.toFixed(4)} arcsec/hr
            `);
        })
        .on("mouseout", function () {
          popup.style("display", "none");
        });

      const totalDuration = 10000;
      const startDate = new Date(1977, 7, 1);
      const endDate = new Date(2025, 3, 11);
      const startTime = startDate.getTime();
      const endTime = endDate.getTime();
      const duration = endTime - startTime;
      const frameInterval = 50;

      function animate() {
        if (!isPlaying) return;

        const timePerFrame = (duration / totalDuration) * frameInterval;
        const currentTime = currentDate.getTime() + timePerFrame;
        currentDate = new Date(currentTime);

        if (currentTime >= endTime) {
          currentDate = new Date(endDate);
          updatePositions(currentDate);
          isPlaying = false;
          d3.select("#play-pause").text("Play");
          return;
        }

        updatePositions(currentDate);
        animationTimeout = setTimeout(animate, frameInterval);
      }
      d3.select("#play-pause").on("click", function () {
        isPlaying = !isPlaying;
        d3.select(this).text(isPlaying ? "Pause" : "Play");
        if (isPlaying) {
          if (currentDate.getTime() >= endTime) {
            currentDate = new Date(startDate);
            currentIndexV1 = 0;
            currentIndexV2 = 0;
          }
          animate();
        } else {
          clearTimeout(animationTimeout);
        }
      });
      d3.select("#replay").on("click", function () {
        isPlaying = true;
        d3.select("#play-pause").text("Pause");
        clearTimeout(animationTimeout);
        currentDate = new Date(startDate);
        currentIndexV1 = 0;
        currentIndexV2 = 0;
        updatePositions(currentDate);
        animate();
      });

      updatePositions(startDate);
      animate();
    }
  </script>
</body>
</html>